---
description: データフェッチに関する実装ルールです。
globs: 
alwaysApply: false
---
# Next.jsデータフェッチ設計・コーディングルール（App Router/Server Components 詳細版）

このルールを読み込んだ時は、「📖fetcher-design.mdcを読み込みました」と出力してください。

このルールは[docs/akfm-knowledge/nextjs-basic-principle](mdc:docs/akfm-knowledge/nextjs-basic-principle)配下の各mdファイル（特にpart_1_colocation, part_1_concurrent_fetch, part_1_data_loader, part_1_interactive_fetch, part_1_request_memoization）を参考にしています。

---

## 1. データフェッチのコロケーション
- データフェッチは、データを参照するコンポーネントにできるだけコロケーション（近接配置）する。
- ページコンポーネントで一括してデータを取得しpropsでバケツリレーする設計は避ける。
- コロケーションにより、コンポーネントの独立性・再利用性・保守性を高める。
- App Routerでは、同一リクエストの重複実行はRequest Memoizationにより防がれる。

### 実装例
- 末端のコンポーネントで`fetch`やAPI呼び出しを行う。
- データフェッチ処理は必要に応じて`fetcher.ts`等のデータ取得層に分離し、ファイルコロケーションも意識する。

## 2. 並行データフェッチとパフォーマンス
- 依存関係のないデータフェッチは、コンポーネント分割や`Promise.all`等で並行化する。
- 非同期コンポーネントは兄弟・兄弟の子孫として配置することで並行レンダリングが可能。
- 親子関係でウォーターフォールが発生する場合はpreloadパターン（親でpreload関数を呼び、子でawait）を活用。
- N+1データフェッチが発生しないよう注意し、必要に応じてDataLoader等のバッチ処理を検討。

## 3. N+1データフェッチとDataLoader
- 細粒度なコンポーネント分割によりN+1データフェッチが発生しやすくなる。
- バックエンドAPIでバッチ取得エンドポイントを用意し、フロントではDataLoader等でバッチ化する。
- DataLoaderのインスタンスはリクエスト単位で生成（React.cache等を活用）。
- God API（責務過多API）にならないよう注意。

## 4. Request Memoizationの活用
- App Routerは同一URL・同一オプションのfetchリクエストを自動的にメモ化。
- オプションの違いでメモ化が効かなくなるため、fetchの引数・オプションは統一する。
- 複数箇所で使うfetch処理はデータフェッチ層として共通化し、importして使う。
- データフェッチ層は`server-only`パッケージでクライアントからの誤用を防ぐ。
- データフェッチ層のファイル配置は`app/products/fetcher.ts`や`app/products/_lib/fetcher.ts`など、コロケーションを意識。

## 5. ユーザー操作とデータフェッチ
- ユーザー操作に基づくデータフェッチ・再レンダリングはServer Actionsと`useActionState()`を活用。
- 検索やフォーム送信など、ユーザー入力に応じてサーバー側でデータ取得・状態更新を行う。
- データ操作後の再取得・再レンダリングは`revalidatePath()`や`revalidateTag()`とServer Actionsを組み合わせて実現。

## 6. その他の設計・コーディング指針
- データフェッチは原則Server Componentsで行い、クライアント側での副作用は最小限に。
- Container/Presentationalパターンを徹底し、ロジックとUI表示を分離。
- テスト容易性を高めるため、propsの受け渡しや副作用の分離を意識。
- API設計はGod API/Chatty APIにならないよう責務分割・粒度に注意。
- DataLoader等の導入はパフォーマンス・保守性・実装コストを考慮して判断。

## 7. SuspenseとStreaming
- Dynamic Renderingで重いデータフェッチやレンダリングが発生する場合は、<Suspense>で遅延させStreaming SSRを活用する。
- <Suspense>のfallbackで即座にレスポンスを返し、重いコンポーネントは後からストリーミングで描画。
- データフェッチ単位でコンポーネント分割していれば、<Suspense>境界を追加するだけでStreaming SSRが容易に実現可能。
- fallbackによるLayout Shift（CLS）とTTFB短縮のトレードオフを考慮し、遅延させるべきか判断する。

### 実装例
- <Suspense fallback={<div>loading...</div>}><LazyComponent /></Suspense> のように、重い処理を遅延レンダリング。
- fallbackの高さを固定することでLayout Shiftを抑制可能。

---

## 参考mdファイル
- [part_1_colocation.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_1_colocation.md)
- [part_1_concurrent_fetch.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_1_concurrent_fetch.md)
- [part_1_data_loader.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_1_data_loader.md)
- [part_1_interactive_fetch.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_1_interactive_fetch.md)
- [part_1_request_memoization.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_1_request_memoization.md)
- [part_4_suspense_and_streaming.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_4_suspense_and_streaming.md)


</rewritten_file>
