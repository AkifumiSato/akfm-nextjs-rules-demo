---
description: コンポーネントの設計に関するルールです。
globs: 
alwaysApply: false
---
# Next.jsコンポーネント設計・コーディングルール（App Router/Server Components 詳細版）

このルールを読み込んだ時は、「📖component-design.mdcを読み込みました」と出力してください。

このルールは[docs/akfm-knowledge/nextjs-basic-principle](mdc:docs/akfm-knowledge/nextjs-basic-principle)配下の各mdファイル（特にpart_2_container_presentational_pattern, part_2_container_1st_design, part_2_composition_pattern, part_2_client_components_usecase）を参考にしています。

---

## 1. Container/Presentationalパターンの徹底
- データ取得・ロジックはContainer Components、UI表示はPresentational Componentsに分離する。
- Container ComponentsはServer Componentsとして実装し、データフェッチを担う。
- Presentational Componentsは`"use client";`が不要な場合はShared Components（Server Components）として実装。
- テスト容易性の観点から、Container/Presentational分離を徹底する。

## 2. Client Componentsのユースケース
- クライアントサイド処理（イベントハンドラ、状態hooks、ブラウザAPI利用）が必要な場合のみClient Componentsを利用。
- サードパーティ製のClient Componentsを利用する場合、必要に応じて`"use client";`でClient Boundaryを明示。
- RSC Payload転送量削減のため、繰り返しレンダリングされる大きなUIはClient Components化を検討。
- Client Componentsは必要最小限にとどめ、Server Components中心の設計を基本とする。

## 3. Compositionパターンの活用
- Client ComponentsはServer Componentsをimportできない制約があるため、children等のpropsでServer Componentsを受け渡すCompositionパターンを活用。
- コンポーネントツリーの末端をClient Componentsにすることで、Client Boundaryを下層に限定。
- 上位層でClient Componentsが必要な場合も、CompositionパターンでServer Componentsをchildrenとして渡す設計を推奨。
- 設計初期からCompositionパターンを意識し、後からの大幅な手戻りを防ぐ。

## 4. Container 1stな設計手順
- 画面設計はまずContainer Componentsのツリー構造を書き出し、Containerのみで設計する。
- Presentational/Client Componentsは後から追加・分割する。
- Container/Presentational/Compositionパターンを組み合わせ、手戻りの少ない設計順序を徹底。
- ディレクトリ構成はContainer単位で分割し、Container配下にPresentational/Client Componentsをコロケーション。
- `_containers`や`_components`等のPrivate Folderを活用し、責務ごとに整理。

## 5. テスト容易性とプライベート定義
- Presentational ComponentsはContainer Componentsの実装詳細（プライベート定義）として扱う。
- テスト容易性を高めるため、Container/Presentational分離・props受け渡し・副作用分離を徹底。

## 6. トレードオフ・注意点
- Client Boundaryの形成位置に注意し、Server Componentsのメリットを最大化。
- Compositionパターンを後から適用する場合の手戻りリスクに注意。
- エコシステム（RTL/Storybook等）のServer Components対応状況も随時確認。

## 7. ディレクトリ構成とファイル分割ルール

### 7.1 基本ディレクトリ構成
Container単位でディレクトリを分割し、App RouterのPrivate Folderを活用した構成を採用する。

```
app
├── <Segment>
│  ├── page.tsx
│  ├── layout.tsx
│  ├── _containers                    // Container Components群（Private Folder）
│  │  ├── <Container Name>            // 例: post-list, user-profile
│  │  │  ├── index.tsx               // Container Componentsをexport（公開インターフェース）
│  │  │  ├── container.tsx           // Container Component実装
│  │  │  ├── presentational.tsx     // Presentational Component実装
│  │  │  ├── fetcher.ts               // 複数回発生するデータフェッチや複雑なデータフェッチ層
│  │  │  ├── types.ts               // 型定義
│  │  │  └── utils.ts               // ユーティリティ関数（必要に応じて）
│  │  └── ...
│  ├── _components                   // 汎用的なShared/Client Components（Private Folder）
│  ├── _lib                         // 汎用的な関数・ユーティリティ（Private Folder）
│  │  └── utils.ts                  // ユーティリティ関数
│  └── _types                       // 型定義（Private Folder）
└── ...
```

### 7.2 Container単位のファイル分割ルール

#### `_container`内必須ファイル
- `index.tsx`: Container Componentsの公開インターフェース。外部からはこのファイル経由でのみアクセス
- `container.tsx`: Container Component本体。データフェッチとビジネスロジックを担当
- `presentational.tsx`: Presentational Component実装。UIの表示責務のみ

#### オプションファイル
- `fetcher.ts`: データフェッチ層。複数回発生するデータフェッチや複雑なデータフェッチ処理を格納
- `types.ts`: Container固有の型定義
- `utils.ts`: Container固有のユーティリティ関数
- `hooks.tsx`: Container固有のCustom Hooks（Client Components用）

### 7.3 Private Folderの活用ルール
- `_`で始まるディレクトリはApp Routerのルーティングディレクトリと明確に区別
- `_containers`: Container Components群
- `_components`: Route Segment内で共通利用されるShared/Client Components
- `_lib`: Route Segment内で共通利用される関数・ユーティリティ
- `_types`: Route Segment内で共通利用される型定義

### 7.4 コロケーションのベストプラクティス
- Container ComponentsはRoute Segmentに密結合するため、可能な限りコロケーション
- Presentational ComponentsはContainer Componentsの実装詳細として同一ディレクトリに配置
- 複数のContainerで共通利用されるコンポーネントは`_components`に配置
- データフェッチ関数は対応するContainerディレクトリ内またはRoute Segmentの`_lib`に配置

### 7.5 import制限とプライベート定義
- Presentational ComponentsはContainer Componentsの実装詳細として扱う
- 外部からのアクセスは`index.tsx`経由のみを原則とする
- [eslint-plugin-import-access](mdc:https:/github.com/uhyo/eslint-plugin-import-access)の導入を推奨し、予期せぬ外部importを制限
- Container配下のファイルは実質的なプライベート定義として設計

### 7.6 設計例
```tsx
// app/posts/[postId]/_containers/post-detail/index.tsx
export { PostDetailContainer } from './container';

// app/posts/[postId]/_containers/post-detail/container.tsx
import { PostDetailPresentation } from './presentational';
import { UserProfileContainer } from '../user-profile';

export async function PostDetailContainer({ postId }: { postId: string }) {
  const post = await getPost(postId);
  
  return (
    <PostDetailPresentation post={post}>
      <UserProfileContainer userId={post.userId} />
    </PostDetailPresentation>
  );
}

// app/posts/[postId]/_containers/post-detail/presentational.tsx
import { ReactNode } from 'react';

interface Props {
  post: Post;
  children: ReactNode;
}

export function PostDetailPresentation({ post, children }: Props) {
  return (
    <article>
      <h1>{post.title}</h1>
      <div>{post.content}</div>
      <aside>{children}</aside>
    </article>
  );
}
```

---

## 参考mdファイル
- [part_2_container_presentational_pattern.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_2_container_presentational_pattern.md)
- [part_2_container_1st_design.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_2_container_1st_design.md)
- [part_2_composition_pattern.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_2_composition_pattern.md)
- [part_2_client_components_usecase.md](mdc:docs/akfm-knowledge/nextjs-basic-principle/part_2_client_components_usecase.md)


</rewritten_file>
